Вопросы которые возникли в процессе и их решение.

1) TTL

Если при добавлении сегмента пользователю он не задается , то будет сохранен на максимальное количество лет, чтобы удалить его можно было только путем удаления сегмента.
Устаревшие записи могут быть не удалены сразу после истечения срока жизни, но возвращаться на запрос актуальных данных пользователя не будут. 

2) Автоматическое попадание в сегмент

Я понял эту задачу так:
Допустим у нас 100 пользователей и есть сегмент с 10-% попаданием.
Тогда только 10 человек из 100 должны туда попасть.
Теперь для каждого пользователя надо решить в какие сегменты он попадает.Как это можно сделать?
Я решил взять за основу алгоритм Фишера — Йетса, но немного изменить.Алгоритм перемешивает случайным образом массив чисел.
Но вместо того чтобы полностью перемешивать массив, я возвращаю следующую перестановку в массиве. После того как размер массива заканчивается, он обновляется до первоначального состояния и так по кругу. Если установить размер массива 100 (так как 100% - максимальный процент) ,то можно получать числа от 1 до 100 без повторений и по кругу. Эти числа я и присваиваю пользователям.
Пример:
На старте создается массив из 100 чисел. 
Поступает запрос на создание пользователя -> 
он получает число от 1 до 100 -> 
потом проверятся в базе user_percentage > segment_percentage. Сегменты, попавшие под условие, добавляются пользователю.
Чтобы такое выполнилось при создании сегмента переданое значение автоматического попадания инвертируется (100 - hitPercentage).
Пример :
10% => 100 - 10 = 90 => только пользователи которым выпало 91-100 попадут ,что ровно 10 процентов.

3) Cache
Для использования кеша написал небольшую обертку над sync.Map. Это может быть не лучшим решением, но так как данных о количестве чтений/записи нет , то не стал усложнять с реализацией sync.Mutex/sync.RWMutex
